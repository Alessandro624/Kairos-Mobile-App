/**
 * Kairos Backend API
 * This API provides endpoints for the Kairos Backend application.
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.models.Page
import io.swagger.client.models.ServiceError
import io.swagger.client.models.UserDTO
import io.swagger.client.models.UserPasswordUpdateDTO
import io.swagger.client.models.UserUpdateDTO

import io.swagger.client.infrastructure.*

class UsersApi(basePath: kotlin.String = "http://10.0.2.2:8080") : ApiClient(basePath) {

    /**
     * Change user password
     * Allows an authenticated user to change their password.
     * @param body Old and new passwords
     * @return void
     */
    fun changePassword(body: UserPasswordUpdateDTO, authorization: kotlin.String?): Unit {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = "Bearer $this" }
        val localVariableBody: kotlin.Any? = body
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/users/change-password",
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )

            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Delete a user
     * Deletes a specific user by their ID. Requires ADMIN role.
     * @param userId ID of the user to delete
     * @return void
     */
    fun deleteUser(userId: kotlin.Any, authorization: kotlin.String?): Unit {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = "Bearer $this" }
        val localVariableConfig = RequestConfig(
            RequestMethod.DELETE,
            "/v1/users/{userId}".replace("{" + "userId" + "}", "$userId"),
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )

            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get all users
     * Retrieves a paginated list of all users. Requires ADMIN role.
     * @param page Page number (default: 0) (optional, default to 0)
     * @param size Number of items per page (default: 10, max: 30) (optional, default to 10)
     * @param sortBy Field to sort by (default: username) (optional, default to username)
     * @param direction Sort direction (default: ASC) (optional, default to ASC)
     * @return Page
     */
    @Suppress("UNCHECKED_CAST")
    fun getAllUsers(
        page: kotlin.Any? = null,
        size: kotlin.Any? = null,
        sortBy: kotlin.Any? = null,
        direction: kotlin.Any? = null, authorization: kotlin.String?
    ): Page {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = "Bearer $this" }
        val localVariableQuery: MultiValueMap =
            mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (sortBy != null) {
                    put("sortBy", listOf(sortBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
            }
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/users", query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Page>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Page
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )

            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get all admin users
     * Retrieves a paginated list of all users with the ADMIN role. Requires ADMIN role.
     * @param page Page number (default: 0) (optional, default to 0)
     * @param size Number of items per page (default: 10, max: 30) (optional, default to 10)
     * @param sortBy Field to sort by (default: username) (optional, default to username)
     * @param direction Sort direction (default: ASC) (optional, default to ASC)
     * @return Page
     */
    @Suppress("UNCHECKED_CAST")
    fun getAllUsersAdmin(
        page: kotlin.Any? = null,
        size: kotlin.Any? = null,
        sortBy: kotlin.Any? = null,
        direction: kotlin.Any? = null, authorization: kotlin.String?
    ): Page {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = "Bearer $this" }
        val localVariableQuery: MultiValueMap =
            mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (sortBy != null) {
                    put("sortBy", listOf(sortBy.toString()))
                }
                if (direction != null) {
                    put("direction", listOf(direction.toString()))
                }
            }
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/users/admin", query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Page>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Page
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )

            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Get current user&#x27;s information
     * Retrieves the information of the currently authenticated user.
     * @return UserDTO
     */
    @Suppress("UNCHECKED_CAST")
    fun getCurrentUser(authorization: kotlin.String?): UserDTO {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = "Bearer $this" }

        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/v1/users/me",
            headers = localVariableHeaders
        )
        val response = request<UserDTO>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDTO
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )

            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Make a user an admin
     * Elevates a specific user&#x27;s role to ADMIN. Requires ADMIN role.
     * @param userId ID of the user to make admin
     * @return UserDTO
     */
    @Suppress("UNCHECKED_CAST")
    fun makeUserAdmin(userId: kotlin.Any, authorization: kotlin.String?): UserDTO {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = "Bearer $this" }
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/users/{userId}/make-admin".replace("{" + "userId" + "}", "$userId"),
            headers = localVariableHeaders
        )
        val response = request<UserDTO>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDTO
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )

            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Make a user an organizer
     * Elevates a specific user&#x27;s role to ORGANIZER. Requires ADMIN role.
     * @param userId ID of the user to make organizer
     * @return UserDTO
     */
    @Suppress("UNCHECKED_CAST")
    fun makeUserOrganizer(userId: kotlin.Any, authorization: kotlin.String?): UserDTO {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = "Bearer $this" }
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/users/{userId}/make-organizer".replace("{" + "userId" + "}", "$userId"),
            headers = localVariableHeaders
        )
        val response = request<UserDTO>(
            localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDTO
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )

            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }

    /**
     * Update a user
     * Updates a specific user&#x27;s information. Only the user themselves can perform this action.
     * @param body User details to update
     * @param userId ID of the user to update
     * @return UserDTO
     */
    @Suppress("UNCHECKED_CAST")
    fun updateUser(
        body: UserUpdateDTO,
        userId: kotlin.Any,
        authorization: kotlin.String?
    ): UserDTO {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["Authorization"] = "Bearer $this" }
        val localVariableBody: kotlin.Any? = body
        val localVariableConfig = RequestConfig(
            RequestMethod.PUT,
            "/v1/users/{userId}".replace("{" + "userId" + "}", "$userId"),
            headers = localVariableHeaders
        )
        val response = request<UserDTO>(
            localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as UserDTO
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException(
                (response as ClientError<*>).body as? String ?: "Client error"
            )

            ResponseType.ServerError -> throw ServerException(
                (response as ServerError<*>).message ?: "Server error"
            )
        }
    }
}
